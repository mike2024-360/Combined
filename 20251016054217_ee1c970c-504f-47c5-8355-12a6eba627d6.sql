-- Create parcels table
CREATE TABLE public.parcels (
  id bigint generated by default as identity primary key,
  tracking_code text generated always as ('PLK' || lpad(id::text, 8, '0')) stored,
  sender_name text not null,
  receiver_name text not null,
  origin text not null,
  destination text not null,
  status text not null default 'pending',
  amount numeric(10,2),
  created_by uuid references auth.users(id),
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Create parcel_locations table for tracking
CREATE TABLE public.parcel_locations (
  id bigint generated by default as identity primary key,
  parcel_id bigint references public.parcels(id) on delete cascade not null,
  location_text text not null,
  latitude numeric(10,7),
  longitude numeric(10,7),
  note text,
  recorded_at timestamptz default now()
);

-- Create admin_users table (separate from auth.users for admin management)
CREATE TABLE public.admin_users (
  id uuid primary key references auth.users(id) on delete cascade,
  full_name text not null,
  email text not null,
  role text not null default 'user',
  status text not null default 'active',
  created_at timestamptz default now()
);

-- Create profiles table for user settings
CREATE TABLE public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  full_name text,
  email text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Enable RLS
ALTER TABLE public.parcels ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.parcel_locations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Parcels policies (authenticated users can read, admins can write)
CREATE POLICY "Anyone can view parcels"
  ON public.parcels FOR SELECT
  USING (true);

CREATE POLICY "Authenticated users can create parcels"
  ON public.parcels FOR INSERT
  WITH CHECK (auth.uid() IS NOT NULL);

CREATE POLICY "Authenticated users can update parcels"
  ON public.parcels FOR UPDATE
  USING (auth.uid() IS NOT NULL);

-- Parcel locations policies
CREATE POLICY "Anyone can view parcel locations"
  ON public.parcel_locations FOR SELECT
  USING (true);

CREATE POLICY "Authenticated users can create locations"
  ON public.parcel_locations FOR INSERT
  WITH CHECK (auth.uid() IS NOT NULL);

-- Admin users policies
CREATE POLICY "Authenticated users can view admin users"
  ON public.admin_users FOR SELECT
  USING (auth.uid() IS NOT NULL);

CREATE POLICY "Authenticated users can manage admin users"
  ON public.admin_users FOR ALL
  USING (auth.uid() IS NOT NULL);

-- Profiles policies
CREATE POLICY "Users can view own profile"
  ON public.profiles FOR SELECT
  USING (auth.uid() = id);

CREATE POLICY "Users can update own profile"
  ON public.profiles FOR UPDATE
  USING (auth.uid() = id);

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers for updated_at
CREATE TRIGGER update_parcels_updated_at
  BEFORE UPDATE ON public.parcels
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- Create function to handle new user registration
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, email)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'full_name', ''),
    NEW.email
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for new user
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

-- Enable realtime for parcel_locations
ALTER PUBLICATION supabase_realtime ADD TABLE public.parcel_locations;